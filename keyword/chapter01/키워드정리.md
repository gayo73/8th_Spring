- 외래키 (Foreign Key)
    
    > 다른 테이블의 기본키를 참조하여 테이블 간의 관계를 정의하는 키
    > 
    
    ![스크린샷 2025-03-20 오전 12.18.05.png](attachment:a17c9b4a-9d8f-46be-bd1f-b0e29f981c75:스크린샷_2025-03-20_오전_12.18.05.png)
    
    자식 테이블 : 외래키가 포함된 테이블
    
    부모 테이블 : 외래키 값을 제공하는 테이블
    
    - 데이터 무결성 : 데이터 값이 정확한 상태
    - 데이터 정합성 : 어떤 데이터들이 값이 서로 일치하는 상태
    - 특징
        - 참조 무결성 : 외래키 값은 반드시 참조하는 테이블(PK 테이블)의 기본키 값 중 하나여야함
        - NULL 허용 : 특정 데이터가 관계를 가지지 않을 수도 있기 때문에, 외래키 컬럼은 NULL 값 O (반드시 특정 데이터 가리켜야 하면 NOT NULL)
        - 삭제 및 업데이트 제약 조건
            - **ON DELETE CASCADE** : 참조된 기본키가 삭제될 경우, 외래키를 가진 행도 함께 삭제
            - **ON DELETE SET NULL** : 참조된 기본키가 삭제되면, 외래키 값을 NULL로 설정
            - **ON DELETE RESTRICT** : 기본키가 참조되고 있을 경우 삭제를 막음
    - 장단점
        - 데이터 무결성 유지 ↔ JOIN 연산 증가로 성능 저하 가능
        - 테이블 간의 명확한 관계 ↔ 외래키 설정 복잡
        - 데이터 중복 방지 ↔ 참조 무결성 제약으로 삽입/삭제 제한
- 기본키 (Primary Key)
    
    > 후보키들중 메인으로 선정되어 테이블에서 각 행을 고유하게 식별하는 키
    > 
    
    ```sql
    CREATE TABLE user {
    	id int PRIMARY KEY
    }
    ```
    
    - 특징
        - 유일성과 최소성을 가짐 (후보키)
            - 후보키 : 각 row를 유일하게 식별할 수 잇는 최소한의 속성들의 집합
        - NULL 값을 가질 수 없음
        - 한 테이블 당 하나만 존재
        - 중복 불가능
    - 장단점
        - 데이터의 무결성 보장 ↔ 기본키가 너무 많으면 관리 복잡
        - 빠른 검색 속도 제공 ↔ 잘못 설정 시 성능 저하
        - 중복 방지로 정확성 유지 ↔ 기본키 변경 시 모든 연관 테이블에 영향
- ER 다이어그램 (Entity Relationship Diagram)
    
    > 데이터베이스 구조를 한 눈에 알아보기 위해 그려놓는 다이어그램
    > 
    - ERD 표기 방법
        - 개체 (Entity) : 단독으로 존재하는 객체
            - 개체를 "사각형"으로 표기 → 데이터베이스를 설계할 때, '테이블'이 Entity로 정의될 수 있다.
        - 속성 (Attribute) : 개체가 가지고 있는 속성
            - ERD에서는 속성을 "원"으로 표기한다.
            - 속성 중 "기본키"는 속성에 밑줄을 그어 표기한다.
        - 관계 (Relationship) : 개체 간의 관계
            - ERD에선 개체를 서로 이으며 어떤 관계를 가지는지 "마름모"로 표기한다.
        - 관계성 표기 방법
        ![스크린샷 2025-03-20 오후 1.06.20.png](attachment:66650d1b-3f6a-40c2-9218-1cff677f8b64:스크린샷_2025-03-20_오후_1.06.20.png)
- 복합 키 (Composite key)
    
    > 2개 이상의 컬럼을 묶어서 하나의 기본키로 지정하는 것
    > 
    
    주로 다대다 관계에 사용
    
    - 특징
        - 관계형 데이터의 무결성 유지 ↔ 복합키 많아지면 인덱스 관리 복잡
            - 외래키(FK)로 활용될 때, 여러 개의 컬럼을 기준으로 관계를 형성할 수 있음.
        - 데이터 중복 방지 ↔ 복합키 참조하는 외래키 복잡해짐
        - 단순한 ID 사용 없이 의미 있는 키 구성 가능
            - ex) `Order` 테이블에서 (`user_id`, `product_id`) 조합을 사용하여 구분 가능
- 연관관계 (Association)
    
    > 테이블 간의 관계를 정의하는 방식
    > 
    - 연관관계를 통해 **하나의 테이블에서 다른 테이블의 데이터를 참조**할 수 있음
    - 주로 외래키(FK)를 사용하여 관계를 설정
    
    | 1:1 관계 | 한 행이 다른 테이블의 한 행과만 연결 | ex) 학생 - ID | 하나의 개체가 **다른 개체의 추가 정보를 보완할 때** 사용 |
    | --- | --- | --- | --- |
    | 1:N 관계 | 한 행이 여러 행과 연결 | ex) 학과 - 학생 | 가장 일반적인 관계로 **부모-자식 관계가 존재할 때** 사용 |
    | N:M 관계 | 여러 해이 여러 행과 연결 | ex) 학생 - 수업 | 직접 연결할 수 없고, 중간 테이블(Join Table)이 필요 |
- 정규화
    
    > 데이터 중복을 최소화하고 데이터 무결성을 보장하는 과정
    > 
    - 함수의 종속성 특징에 의해 하나의 테이블을 여러 개로 분해하는 과정
        
        ![스크린샷 2025-03-20 오후 3.53.41.png](attachment:c9c85bb2-1a66-45db-8f96-8ee54d7a3e7f:스크린샷_2025-03-20_오후_3.53.41.png)
        
    1. 제 1 정규화 (1NF)
        
        비정규화된 형태의 데이터에서 모든 속성이 **원자적**이 되도록 하는 것
        
        도메인이 원자가 되어야 함을 의미
        
    2. 제 2 정규화 (2NF)
        
        제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것
        
        기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미
        
    3. 제 3 정규화 (3NF)
        
        제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것
        
    4. BCNF 정규화
        
        제 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
        
    5. 다치 종속
        
        하나의 속성 값으로 여러 집합의 결과 값이 나올 때, 이런 결과를 테이블 안에서 허용하지 않도록 하는 것
        
    6. 조인 종속
        
        두 개의 테이블로 분해했을 때, 원래의 테이블로 돌아갈 수 있어야 하나, 실패할 경우 **세 개의 테이블로** 분해해야 할 수 있음
        
    - 특징
        - 1NF, 2NF, 3NF, BCNF 등의 단계로 나뉨
        - 중복 데이터 최소화
        - 하나의 속성 안에는 하나의 값만 존재
    - 장단점
        - 데이터 무결성 보장 ↔ JOIN 연산 증가로 성능 저하 가능
        - 저장 공간 절약 ↔ 너무 높은 정규화는 과도한 복잡성 유발
- 반 정규화
    
    > 정규화된 데이터 모델을 **일부 해제하여 성능을 향상**시키는 과정
    > 
    
    데이터를 조회할 때 조인으로 인한 성능저하가 예상될 때 성능이 저하될 것이 예상되는 경우 수행
    
    - 특징
        - 의도적으로 정규화 원칙을 위배하는 행위
        - 중복 데이터를 허용하여 조회 속도를 향상
        - 자주 사용하는 데이터는 한 테이블에 합쳐 저장
        - 정규화가 끝난 후 성능 이슈가 있을 때 가지는 과정이며, 정규화처럼 일정한 규칙 존재
    - 장단점
        - 조회 속도 성능 향상 ↔ 데이터 중복 증가로 무결성 관리 어려움
        - JOIN 연산 감소 ↔ 데이터 일관성 유지 어려움